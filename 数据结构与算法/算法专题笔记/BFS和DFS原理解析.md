遍历图的两种最常用的方法，分别为广度优先遍历和深度优先遍历

## BFS

广度优先算法（Breadth-First-Search），简称BFS，是一种图形搜索演算法.

> 广度优先遍历BFS（Breadth First  Search），其主要思想是从起始点开始，将其邻近的所有顶点都加到一个队列（FIFO）中去，然后标记下这些顶点离起始顶点的距离为1.最后将起始顶点标记为已访问，今后就不会再访问。然后再从队列中取出最先进队的顶点A，也取出其周边邻近节点，加入队列末尾，将这些顶点的距离相对A再加1，最后离开这个顶点A。依次下去，直到队列为空为止。从上面描述的过程我们知道每个顶点被访问的次数最多一次（已访问的节点不会再访问），而对于连通图来说，每个顶点都会被访问。加上每个顶点的邻接链表都会被遍历，因此BFS的时间复杂度是Θ（V+E），其中V是顶点个数，E是边数，也就是所有邻接表中的元素个数。

一般情况下我们是用队列来实现，先进先出，使用队列保存未被检测的结点。结点按照宽度优先的次序被访问和进出队列。思路大概是这样：

1.先初始化队列q；
2.从起点开始访问，并且改变他的状态为已经访问；
3.如果他的队列非空，取出首个元素，将它弹出！
4.如果u==目标状态，然后对所以与u邻近的点进入队列；
5.标记它已经被访问！

记忆：
 1、只要一看到要找最短的路径：bfs  or  最短路。 无权用bfs，有权用最短路。
 2、如果第二次回到刚才已走过的点的时候有状态参数变化，那么就不能book。

BFS访问得到的每个节点与起始顶点的距离是起始顶点到达该顶点的最短距离。从感性认识上来说，BFS向外扩散的方式得到的距离就是最短距离

## DFS

一直往深处走，直到找到解或者走不下去为止。DFS基于递归思想，递归思想就是把一个事拆分成若干见相同的小事共同组合完成。

> DFS（Depth First  Search）深度优先搜索是从起始顶点开始，递归访问其所有邻近节点，比如A节点是其第一个邻近节点，而B节点又是A的一个邻近节点，则DFS访问A节点后再访问B节点，如果B节点有未访问的邻近节点的话将继续访问其邻近节点，否则继续访问A的未访问邻近节点，当所有从A节点出去的路径都访问完之后，继续递归访问除A以外未被访问的邻近节点。

思考深搜要注意三个地方

- “顺序”：就是要找一种搜索顺序，能把各种情况都枚举出来
- “回溯” ：回溯说白了就是在一个dfs内，结束了调用的dfs，回到原来的进程。回溯回到原来的进程后，一般都要“恢复现场” 。记住 , 一但你从一个深搜出来 ， 就马上恢复现场，就像事情没发生过一样。当然，不一定所有题目都要恢复现场。（深搜无模板，看题目而定）
- “剪枝”：剪枝就是把不必要的搜索进程砍掉

题目：走迷宫

## 总结

总的来说，BFS多用于寻找最短路径的问题，DFS多用于快速发现底部节点。